from gdb.unwinder import Unwinder
from gdb.FrameDecorator import FrameDecorator
import itertools

class UnwindOp:
    """Dwarf unwind op"""

    # Dwarf unwind info opcodes
    DW_CFA_offset = 0x80
    DW_CFA_register = 0x09
    DW_CFA_def_cfa = 0x0c
    DW_CFA_def_cfa_register = 0x0d
    DW_CFA_def_cfa_offset = 0x0e

    def __init__(self, op, when, reg, val):
        self.op = op
        self.when = when
        self.reg = reg
        self.val = val

class TrampInfo:
    """Debug information for a trampoline"""
    def __init__(self, name, code, code_size, unwind_ops):
        self.name = name;
        self.code = code
        self.code_size = code_size
        self.unwind_ops = unwind_ops

# FIXME: Reset this on restart
class MonoDebugInfo:
    """Manages the debug info generated by the runtime"""
    MAJOR_VERSION = 1
    MINOR_VERSION = 0

    def __init__(self):
        self.var = gdb.lookup_global_symbol("mono_gdb_debug_info")
        self.addr = None
        self.inited = False
        self.init_failed = False
        self.ntrampolines = 0
        self.trampolines = []
        pass

    # Initialize self.addr to a Gdb.Value which points to the mono debug info
    def init(self):
        if self.var == None or self.init_failed:
            return
        if self.addr == None:
            addr = self.var.value()
            if int(addr) == 0:
                # Not initialized yet
                return
            val = addr.dereference()
            version = int(val ["version"])
            if version != (self.MAJOR_VERSION << 16) | self.MINOR_VERSION:
                self.init_failed = True
                raise RuntimeError("Version mismatch with the gdb debug support in the runtime.")
            self.inited = True
            self.addr = addr
        pass

    # Decode a GdbTrampInfo C structure int a TrampInfo instance
    def decode_tramp_info(self, tinfo_var):
        nunwind_ops = int(tinfo_var["nunwind_ops"])
        unwind_ops = []
        ops_var = tinfo_var["unwind_ops"]
        for i in range(0, nunwind_ops):
            op_var = (ops_var + i).dereference()
            unwind_ops.append(UnwindOp(int(op_var["op"]), int(op_var["when"]), int(op_var["reg"]), int(op_var["val"])))
        tinfo = TrampInfo(tinfo_var["name"].string(), int(tinfo_var["code"]), int(tinfo_var["code_size"]), unwind_ops)
        return tinfo
                        
    # Update the gdb side data structures with the changes on the runtime side
    def update(self):
        self.init()
        if not self.inited:
            return
        val = self.addr.dereference()
        # FIXME: Really update
        ntramp = int(val ["ntrampolines"])
        if ntramp > self.ntrampolines:
            trampolines_val = val ["trampolines"]
            for i in range(self.ntrampolines, ntramp):
                tinfo_var = (trampolines_val + i).dereference()
                tinfo = self.decode_tramp_info(tinfo_var)
                self.trampolines.append(tinfo)
            self.ntrampolines = ntramp
        pass

    def lookup_ip(self, ip):
        self.update()
        if not self.inited:
            return
        ip = int(ip)
        # FIXME: Speed this up
        for i in range(0, self.ntrampolines):
            info = self.trampolines [i]
            if ip >= info.code and ip < info.code + info.code_size:
                return info
        return None

class FrameId(object):
    def __init__(self, sp, pc):
        self._sp = sp
        self._pc = pc

    @property
    def sp(self):
        return self._sp

    @property
    def pc(self):
        return self._pc

class MonoUnwinder(Unwinder):
    def __init__(self, info):
        Unwinder.__init__(self, "Mono Unwinder")
        self.info = info
        self.char_ptr_t = gdb.lookup_type("unsigned char").pointer()
        self.char_ptr_ptr_t = self.char_ptr_t.pointer()
        self.enabled = True

    def _read_word(self, address):
        return address.cast(self.char_ptr_ptr_t).dereference()

    def __call__(self, pending_frame):
        ip = pending_frame.read_register("rip")
        info = self.info.lookup_ip(ip)
        if info == None:
            return None

        unwind_ops = info.unwind_ops
        ip_offset = ip - info.code
        frame_id = FrameId(pending_frame.read_register("rsp"), pending_frame.read_register("rip"))
        unwind_info = pending_frame.create_unwind_info(frame_id)

        # Process the dwarf unwind info emitted by the JIT
        cfa_reg = -1
        cfa_offset = 0
        for op in unwind_ops:
            if op.when > ip_offset:
                break
            if op.op == UnwindOp.DW_CFA_def_cfa:
                cfa_reg = op.reg
                cfa_offset = op.val
                #print("CFA: %d+0x%x" % (cfa_reg, cfa_offset))
            elif op.op == UnwindOp.DW_CFA_offset:
                pass
            elif op.op == UnwindOp.DW_CFA_def_cfa_offset:
                cfa_offset = op.val
                #print("CFA: %d+0x%x" % (cfa_reg, cfa_offset))
            elif op.op == UnwindOp.DW_CFA_def_cfa_register:
                cfa_reg = op.reg
                #print("CFA: %d+0x%x" % (cfa_reg, cfa_offset))
            else:
                raise RuntimeError ("Unknown dwarf unwind op %d" % (op.op))
        cfa = pending_frame.read_register(cfa_reg) + cfa_offset
        #print("CFA: %d+0x%x == 0x%x" % (cfa_reg, cfa_offset, cfa))
        for op in unwind_ops:
            if op.when > ip_offset:
                break
            if op.op == UnwindOp.DW_CFA_offset:
                reg_val = self._read_word(cfa + op.val)
                #print("REG %d at cfa+%x == 0x%x." % (op.reg, op.val, reg_val))
                unwind_info.add_saved_register(op.reg, reg_val)
        unwind_info.add_saved_register("rsp", cfa)
        return unwind_info

class TrampolineFrameDecorator(FrameDecorator):
    def __init__(self, base, info):
        super(TrampolineFrameDecorator, self).__init__(base)
        self.base = base
        self.info = info

    def function(self):
        return self.info.name

class MonoFrameFilter():
    def __init__(self, info):
        self.name = "mono"
        self.priority = 1
        self.enabled = True
        self.info = info

    def filter(self, frame_iter):
        for frame in frame_iter:
            ip = frame.address()
            info = self.info.lookup_ip(ip)
            if info != None:
                try:
                    yield TrampolineFrameDecorator(frame, info)
                except RuntimeError as e:
                    print(e)
            else:
                yield frame

mono_objfile = gdb.current_objfile()

info = MonoDebugInfo()

mono_objfile.frame_filters["mono"] = MonoFrameFilter(info)
gdb.unwinder.register_unwinder(None, MonoUnwinder(info), True)
